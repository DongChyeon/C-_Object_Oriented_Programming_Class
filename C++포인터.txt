포인터 : 메모리 주소를 포함하는 변수로써 다른 변수의 위치 값(주소)을 저장하는데 사용

형식
type *var-name;
Type : 포인터의 기본형
var-name : 포인터 변수의 이름

&: 피연산자의 메모리 주소를 반환하는 단항 연산자
ex) balptr = &balance;
     balance 변수의 메모리 주소를 balptr에 넣는다.
*: 피연산자에 의해 명시된 주소에 위치한 변수의 값을 반화하는 단항 연산자
ex) value = *balptr;
     balance의 값을 value에 넣는다.

포인터 산술식
++, --, +, - (곱하기 나누기 안됨)
p++;의 경우 1이 더해지는 것이 아니라 자료형의 크기가 더해짐
ex) int *p1의 경우 int 자료형의 크기가 4바이트이므로 4가 더해짐
     p1 = p1+9일 경우 9*4=36이 더해짐
포인터의 비교
==, <, >
포인터 비교가 의미있는 결과다 되기 위해 두 개의 포인터는 서로 서로 어떤 관계를 가져야만 함

char str[80];은 엄밀히 말하면 포인터 변수(배열의 이름은 일종의 포인터 변수)
ex) char str[80];
     char *p1;
     p1 = str; 에서 str[4] = *(p1+4)	// p1[4]도 가능
str과 p1의 차이는 p1은 다른 변수의 주소를 저장할 수 있지만 str은 아니다.

컴파일러가 문자열 리터럴을 문자열 테이블에 저자하고 그 문자열에 대한 포인터를 생성함
#include <iostream>
using namespace std;

int main() {
	char *s;	// 2015버젼까지는 정상작동하나 2017 버젼부터는 앞에 const를 붙여야함.
	s = "Pointer are fun to use.\n";
	cout << s;
	return 0;
}

전통적으로 포인터가 널 값(0)을 가진다면 아무 것도 가라키지 않는다고 가정한다.
사용되지 않은 포인터에 널 값을 넣고 널 포인터의 사용을 피한다면, 초기화되지 않은 포인터를 사용하는 것을 피할 수 있다.
포인터가 선언될 때 어떤 형의 포인터도 널로 초기화될 수 있다.

다중 간접 접근(이중, 삼중 포인터)의 경우 *을 그 수만큼 붙여야 한다.

포인터에 관련된 실수 :  초기화되지 않은 포인터, 무의미한 포인터 비교, 포인터를 다시 설정하지 않는 실수