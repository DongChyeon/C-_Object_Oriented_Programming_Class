C++그 밖의 자료형과 연산자

const 접근자
const로 선언된 변수는 프로그램의 실행 동안 값 변경이 불가능
ex) const double version = 3.2;
용도) const포인터 매개변수 생성 - 매개변수가 가리키는 대상이 함수에 의해 수정되는 것을 방지
       참조 매개변수에 사용 - 함수에서 참조 매개변수가 참조하는 변수를 수정하는 것을 방지
       이름을 갖는 상수 생성 
ex)
포인터 매개변수
int main() {
	code("this is a test");
	return 0;
}

void code(const char* str) {
	while (*str) {
		// *str = *str + 1 불가
		cout << (char)(*str+1);
		str++;
	}
}
참조 매개변수
void f(const int& i) {
	i = 100 //수정 불가
}
--------------------------------------------------------------------------------
기억공간 종류 지정자
1. auto : 지역변수 선언, 디폴트 지정자이므로 생략 가능
2. extern : 다른 파일에 있는 전역 변수 선언
3. register : CPU의 레지스터에 저장, 빠른 접근 가능
4. static : 자신의 함수 또는 파일에서 영구적인 변수, 함수 외부에 알려지지 않음
	(함수가 끝나도 유지)
static 지역변수
1. static 변수가 함수 호출들 사이에서 값을 유지
2. 함수가 복귀할 떄 소멸되지 않는다.
3. 다소 제한된 범위를 가진 전역변수로 볼 수 있다.
4. 프로그램 실행이 시작할 때 단 한번 초기화된다.
static 전역변수
선언된 파일에서만 알려지는 전역변수를 생성한다.
----------------------------------------------------------------------------------
비트 연산자 : 바이트 또는 워드 내의 비트들을 직접 조작
& : AND
| : OR
^ : exclusive OR (XOR)
~ : 1의 보수(NOT)
>> : 오른쪽 시프트
<< : 왼쪽 시프트 (cout << :연산자 중복)
----------------------------------------------------------------------------------
복합 치환문
다른 연산을 치환문과 결합한 형태의 치환문
복합 치환문 연산자는 C++에 있는 모든 이항 연산자들과 함께 쓸 수 있다.
ex) +=, -=,....
----------------------------------------------------------------------------------
콤마 연산자
여러 개의 식을 함께 묶는다
콤마로 분리된 식들의 리스트의 값은 맨 오른쪽에 잇는 식의 값으로 다른 식들의 값을 버린다.
ex) j = 10;
i = (j++, j+100, 999+j);	// i는 1010
----------------------------------------------------------------------------------
다중 치환문
많은 변수들에게 같은 값을 치환 ex) int a, b, c = 10
----------------------------------------------------------------------------------
sizeof 사용하기
자료형의 크기를 바이트 수로 알려줌
ex) sizeof(int) = 4
----------------------------------------------------------------------------------
new와 delete를 사용하는 동적 할당
C++이 정보를 컴퓨터의 메인 메모리에 저장하는 두 가지 방법
1. 변수들의 사용
컴파일 시간에 고정되어, 프로그램의 실행 동안에 변경될 수 없다.
2. C++의 동적 할당 시스템 사용
heap을 사용하여 필요한 만큼의 공간을 할당
heap의 영역이 충분치 않다면 예외 발생
동적으로 할당되는 기억공간은 실행 시에 얻는다
ex) pointer-var = new var-type;       int *p;     p=new int;      *p =20;      delete p;//p가 가리키는 메모리 해제
     delte pointer-var;

배열 할당
할당 : poiner-var = new type[size];
해제 : delete []pointer-var;